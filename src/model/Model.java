package model;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.ArrayList;
import java.util.Observable;
import java.util.Observer;

import model.interpreter.ParserAutoPilot;
import model.interpreter.Parser;

public class Model extends Observable implements Observer {
    // Data members.
	private ClientSimulator clientSimulator;
    public static volatile boolean stop = false;
    public static volatile boolean turn = true;
    public static volatile boolean head = false;
    private Interpreter interpter;
    private static Socket socketpath;
    private static PrintWriter outpath;
    private static BufferedReader in;
    double startX;
    double startY;
    double planeX;
    double planeY;
    double markX;
    double markY;
    double offset;
    double currentlocationX;
    double currentlocationY;
    double currentHeading;
    ArrayList<String[]> intersections=new ArrayList<>();
    Thread route;
    Thread rudder;
    int[][] data;
    int indexPlan = 0;

    // CTOR.
    public Model() {
        clientSimulator = new ClientSimulator();
        interpter = new Interpreter();
        route = new Thread(() -> {this.routeStart();});
        rudder = new Thread(() -> {this.rudderStart();});
    }

    public void GetPlane(double startX,double startY, double offset){
        this.offset = offset;
        this.startX = startX;
        this.startY = startY;
            new Thread(() -> {
                Socket socket = null;
                try {
                    socket = new Socket("127.0.0.1", 5402);
                    System.out.println("Connect to server...");
                    
                    PrintWriter out = new PrintWriter(socket.getOutputStream());
                    BufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                    
                    while(!stop){
                        out.println("dump /position");
                        out.flush();
                        String line;
                        ArrayList<String> lines = new ArrayList<>();
                        
                        while (!(line = br.readLine()).equals("</PropertyList>")){
                            if(!line.equals("")) { lines.add(line); }
                        }
                        
                        String longtitude = lines.get(2);
                        String latitude = lines.get(3);
                        String[] x = longtitude.split("[<>]");
                        String[] y = latitude.split("[<>]");
                    
                        br.readLine();
                        out.println("get /instrumentation/heading-indicator/indicated-heading-deg");
                        out.flush();
                        
                        String[] h = br.readLine().split(" ");
                        int tmp = h[3].length();
                        currentlocationX = Double.parseDouble(x[2]);
                        currentlocationY = Double.parseDouble(y[2]);
                        currentHeading = Double.parseDouble(h[3].substring(1,tmp-1));
                        String[] data = {"plane",x[2],y[2],h[3].substring(1,tmp-1)};
                        this.setChanged();
                        this.notifyObservers(data);
                        
                        try {
                            Thread.sleep(250);
                        } catch (InterruptedException e) { e.printStackTrace(); }
                    }

                    socket.close();
                    
                } catch (IOException e) {
                    e.printStackTrace();
                    try {
                        socket.close();
                    } catch (IOException ex) { ex.printStackTrace(); }
                }

            }).start();
        }

    public void parse(String[] script) { interpter.interpet(script); }

    public void execute() { interpter.execute(); }

    public void stopAutoPilot() { interpter.stop(); }

    public void connectPath(String ip,int port) {
        try {
            socketpath = new Socket(ip,port);
            outpath = new PrintWriter(socketpath.getOutputStream());
            in = new BufferedReader(new InputStreamReader(socketpath.getInputStream()));
        } catch (IOException e) { e.printStackTrace(); }
    }

    public void connectManual(String ip, int port) { clientSimulator.Connect(ip,port); }

    public void send(String[] data) { clientSimulator.Send(data); }

    public void findPath(int planeX, int planeY, int markX, int markY, int[][] data) {
        this.planeX = planeX;
        this.planeY = planeY;
        this.markX = markX;
        this.markY = markY;
        this.data = data;
       
        new Thread(() -> {
        	int i;
        	int j;
            
        	System.out.println("\tsending problem...");
           
            for (i = 0; i < data.length; i++) {
            	System.out.print("\t");
                for (j = 0; j < data[i].length - 1; j++) {
                	outpath.print(data[i][j] + ",");
                }
             
                outpath.println(data[i][j]);
             }
            
            outpath.println("end");
            outpath.println(planeX+","+planeY);
            outpath.println(markX+","+markY);
            outpath.flush();
            
            String usol = null;
            
            try {
            	usol = in.readLine();
                } catch (IOException e) { e.printStackTrace(); }
                
            System.out.println("\tsolution received");
            System.out.println(usol);
            String[]tmp=usol.split(",");
            String[] notfiy=new String[tmp.length+1];
            
            notfiy[0]="path";
            
            for(i=0;i<tmp.length;i++) { notfiy[i+1]=tmp[i]; }
            
            this.setChanged();
            this.notifyObservers(notfiy);
            this.buildFlyPlan(tmp);
           
            if(!route.isAlive()) { 
            	route.start(); 
            } else if(Model.turn==false) { 
            	route.interrupt();
                route.start();
                }
        }).start();
    }

    private void rudderStart() {
        while(!head && (indexPlan < intersections.size())) {
            boolean flag;
            double heading;
            double headingC;
            double tmp;
            
            heading = Integer.parseInt(intersections.get(indexPlan)[0]);
            headingC = currentHeading;
            
            int degree, degreeCom;
            degree = (int) (heading - headingC);
            
            if (degree < 0) { degree += 360; }
            
            degreeCom = 360 - degree;
            double turning = headingC;
            
            if (degree < degreeCom) {
                turning = turnPlus(headingC);
                tmp = turning - headingC;
                flag = true;
            } else {
                turning = turnMinus(headingC);
                tmp = (turning - headingC);
                flag = false;
            }
            
            if(tmp>=340) {
                tmp=360-tmp;
            } else if(tmp<-340) {
                tmp=-360-tmp;
            }
            
            if((Math.abs(heading-headingC) > 9) && (Math.abs(heading-headingC) < 349)) {
                Parser.symTbl.get("r").setV(tmp/20);
                Parser.symTbl.get("e").setV(0.095);
            } else {
                Parser.symTbl.get("r").setV(tmp / 100);
                Parser.symTbl.get("e").setV(0.053);
            }
            
            try {
                Thread.sleep(250);
            } catch (InterruptedException e) { e.printStackTrace(); }
        }
    }
    
    private void routeStart() {
        while(turn) {
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) { e.printStackTrace(); }
        }
        
        rudder.start();
        
        double intersectionX;
        double intersectionY; 
        double pathX; 
        double pathY; 
        double endX; 
        double endY;
        
        pathX = startX + (planeY - 1) * offset;
        pathY = startY - (planeX - 1) * offset;
        endX = startX + (markY - 1) * offset;
        endY = startY - (markX - 1) * offset;
        
        int radiusX = 17;
        int radiusY = 7;
        
        while((!turn) && indexPlan<intersections.size()) {
            int h = Integer.parseInt(intersections.get(indexPlan)[0]);
            int n = Integer.parseInt(intersections.get(indexPlan)[1]);
            switch (h) {
                case 360:
                    intersectionX = pathX;
                    intersectionY = pathY + (n - 1) * offset;
                    break;
                case 45:
                    intersectionX = pathX + (n - 1) * offset;
                    intersectionY = pathY + (n - 1) * offset;
                    break;
                case 90:
                    intersectionX = pathX + (n - 1) * offset;
                    intersectionY = pathY;
                    break;
                case 135:
                    intersectionX = pathX + (n - 1) * offset;
                    intersectionY = pathY - (n - 1) * offset;
                    break;
                case 180:
                    intersectionX = pathX;
                    intersectionY = pathY - (n - 1) * offset;
                    ;
                    break;
                case 225:
                    intersectionX = pathX - (n - 1) * offset;
                    intersectionY = pathY - (n - 1) * offset;
                    break;
                case 270:
                    intersectionX = pathX - (n - 1) * offset;
                    intersectionY = pathY;
                    break;
                case 315:
                    intersectionX = pathX - (n - 1) * offset;
                    intersectionY = pathY + (n - 1) * offset;
                    break;
                default:
                    intersectionX = 0;
                    intersectionY = 0;
            }
            
            if(indexPlan == intersections.size()-1) {
                intersectionX=endX;
                intersectionY=endY;
                radiusY = 20;
            }
            
            while ((Math.abs(currentlocationX - intersectionX)) > (radiusX * offset) || (Math.abs(currentlocationY - intersectionY)) > (radiusX * offset)) {
                try {
                    Thread.sleep(250);
                } catch (InterruptedException e) { e.printStackTrace(); }
            }

            indexPlan++;

            pathX = currentlocationX;
            pathY = currentlocationY;
        }
        
        Parser.symTbl.get("goal").setV(1);
    }
    
    private void buildFlyPlan(String[] solution) {
        intersections = new ArrayList<>();
        int count = 0;
        for(int i = 0; i < (solution.length - 1); i++) {
            if(solution[i].equals(solution[i+1])) {
                count++;
            } else {
                String[] tmp = new String[2];
                tmp[0] = solution[i];
                tmp[1] = count + 1 + "";
                intersections.add(tmp);
                count=0;
            }
        }
        
        if(count != 0) {
            String[] tmp=new String[2];
            tmp[0]=solution[solution.length - 1];
            tmp[1]=count + 1 + "";
            intersections.add(tmp);
        }
        
        for(int i = 0; i < intersections.size(); i++) {
            int tmp = Integer.parseInt(intersections.get(i)[1]);
            if(tmp <= 5) {
                int index;
                int tmp2;
                
                if(i!=0) { 
                	index = i - 1;
                } else {
                    index = i + 1;
                }
                
                tmp2 = Integer.parseInt(intersections.get(index)[1]);
                tmp2 += tmp;
                String[] strings = new String[]{intersections.get(index)[0], tmp2+ ""};
                intersections.set(index,strings);
                intersections.remove(i);
            }
        }
        
        for(int i=0;i<intersections.size()-1;i++) {
            if(intersections.get(i)[0].equals(intersections.get(i+1)[0])) {
                int tmp = Integer.parseInt(intersections.get(i)[1]) + Integer.parseInt(intersections.get(i + 1)[1]);
                String s = "" + tmp;
                intersections.get(i)[1] = s;
                intersections.remove(i+1);
            }
        }
        
        for(int i=0;i<intersections.size();i++) { 
            int tmp = Integer.parseInt(intersections.get(i)[1]);
            String direct = intersections.get(i)[0];
            int degree = clacDegree(direct);
            if((tmp <= 15) && (tmp > 5)) {
                if(i+1<intersections.size())
                {
                    if(degree!=360 && degree!=90) {
                        if (degree < clacDegree(intersections.get(i + 1)[0]))
                            degree += 45;
                        else
                            degree -= 45;
                    }
                    else if(degree == 360){
                        if(clacDegree(intersections.get(i + 1)[0]) == 90)
                            degree = 45;
                        else
                            degree -= 45;
                    }
                    else if(degree == 90)
                    {
                        if(clacDegree(intersections.get(i + 1)[0]) == 360)
                            degree = 45;
                        else
                            degree -= 45;
                    }
                }
            }

            String s = new String();
            s = degree + "";
            intersections.get(i)[0] = s.intern();
        }
    }
    
    private int clacDegree(String string) {
    	int degree = 0;
        
    	switch (string) { 
            case "Down":
                degree = 180;
                break;
            case "Right":
                degree = 90;
                break;
            case "Left":
                degree = 270;
                break;
            case "Up":
                degree = 360;
        }
    	
        return degree;
    }
    
    public interface Turn { double Do(double x); }

    public void makeTurn(Turn t,double heading,double currentHeading) {
        double minus = Math.abs(heading - currentHeading);
        double h = currentHeading;
        
        while((minus > 30) && (minus < 335) && (!Model.turn)) {
            double tmp = t.Do(h);
            Parser.symTbl.get("hroute").setV(tmp);
            try {
                Thread.sleep(2500);
            } catch (InterruptedException e) { e.printStackTrace(); }
            
            minus = Math.abs(heading-tmp);
            h = tmp;
        }
        
        Parser.symTbl.get("hroute").setV(heading);
    }
    
    public double turnPlus(double currentHeading) {
        int tmp = (int)currentHeading + 7;
        
        if(tmp>360) { tmp-=360; }
        
        return tmp;
    }
    
    public double turnMinus(double currentHeading) {
        int tmp = (int)currentHeading - 7;
        
        if(tmp < 0) { tmp += 360; }
        
        return  tmp;
    }

    public void stopAll() {
        Model.stop = true;
        if (outpath != null) { outpath.close(); }
        
        try {
            if ( in != null) { in.close(); }
            
            if (socketpath!=null) { socketpath.close(); }
        } catch (IOException e) { e.printStackTrace(); }
        
        clientSimulator.stop();
        
        ParserAutoPilot.exe.interrupt();
        ParserAutoPilot.close = true;
        Model.turn = true;
    }

    @Override
    public void update(Observable o, Object arg) { }
}